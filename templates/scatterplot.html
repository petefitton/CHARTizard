<script>

// -----------------------Initial setup--------------------------------//

// Setup size of svg/dimensions
// Setup domain of x and y
// Setup scatterplotTooltip
// Setup dropdown menus


// ---------------------------d3.csv()--------------------------------//

// Variable declarations and processing
	// Format data
	// y and x axis variable name declarations
	// defs/linearGradients/stops for coloring dots
	// hide/hidehandler
// Function declarations
	// y dropdown menu handler
	// x dropdown menu handler
	// updateScatter function declaration
		// Garage collect
		// Reset/Format/Create
			// Domain setup
			// Call varNameFormat() - define formatted variable names
			// Call enterDots
			// Add x and y axes
			// Add x and y axes text
			// Regression Line - declarations for vars/functions and creation of line
			// Add scatterTitle and corresponding rect
	// varNameFormat declaration with tuple xAxisVarFormatted, yAxisVarFormatted declarations
	// enterDots declaration
	// exitDots declaration
// Run initialization/function calls
	// enterDots()





// set/calculate variables for dimensions and margins of scatterplot
var margin = {top: 60, right: 50, bottom: 60, left: 65},
	width = window.innerWidth - margin.left - margin.right - 30,
	height = 600 - margin.top - margin.bottom;

// set the ranges of x and y axes
var x = d3.scaleLinear().range([0, width]);
var y = d3.scaleLinear().range([height, 0]);

// scatterSvg create and setup + group element create/append that sets area to start in the corner with margins applied
var scatterSvg = d3.select(".scatterDiv").append("svg")
	.attr("width", width + margin.left + margin.right)
	.attr("height", height + margin.top + margin.bottom)
	.attr("color", "red")
	.attr("style", "background-color: #ececec")
	.call(responsivefy)
.append("g")
	.attr("transform",
		  "translate(" + margin.left + "," + margin.top + ")");

let scatterplotTooltip = d3.select('.scatterDiv').append('div')
	.attr('class', 'scatterplotTooltip')
	.style("position", "absolute")
	.style("opacity", 0)
	.style("border", "1px solid black")
	.style("padding", "5px")
	.style("background-color", "white")
	.style("cursor", "default")
	.style("top", "0px")
	.style("left", "50%")

let yDropdownLabel = d3.select('.scatterDiv').append('label')
	.text("Y Variable")
	.style("position", "absolute")
	.style("right", (margin.right / 2) + "px")
	.style("top", (margin.top / 2) + "px")

let yDropdown = yDropdownLabel.append('select')
	.attr("class", "yDropdown")
	.style("display", "block")

yDropdown.append('option')
	.text("base_total")
	.attr("value", "base_total")

yDropdown.append('option')
	.text("attack")
	.attr("value", "attack")

yDropdown.append('option')
	.text("defense")
	.attr("value", "defense")

yDropdown.append('option')
	.text("hp")
	.attr("value", "hp")

yDropdown.append('option')
	.text("sp_attack")
	.attr("value", "sp_attack")

yDropdown.append('option')
	.text("sp_defense")
	.attr("value", "sp_defense")

yDropdown.append('option')
	.text("speed")
	.attr("value", "speed")

let xDropdownLabel = d3.select('.scatterDiv').append('label')
	.text("X Variable")
	.style("position", "absolute")
	.style("right", (margin.right * 3) + "px")
	.style("top", (margin.top / 2) + "px")

let xDropdown = xDropdownLabel.append('select')
	.attr("class", "xDropdown")
	.style("display", "block")

xDropdown.append('option')
	.text("capture_rate")
	.attr("value", "capture_rate")

xDropdown.append('option')
	.text("weight_kg")
	.attr("value", "weight_kg")

xDropdown.append('option')
	.text("height_m")
	.attr("value", "height_m")


// Get the data and process data within a large function
d3.csv("{{url_for('static', filename='data/pokemon.csv')}}").then(function(data) {

// -----------------------Variable declarations and processing--------------------------------//

	// Test filtering data (remove all pokemon from data that have capture_rate === 120)
	// data = data.filter(function(d){ return d.capture_rate != "120" })

	// format data from strings to numbers
	data.forEach(function(d) {
		d.capture_rate = +d.capture_rate;
		d.base_total = +d.base_total;
		d.attack = +d.attack;
		d.defense = +d.defense;
		d.hp = +d.hp;
		d.sp_attack = +d.sp_attack;
		d.sp_defense = +d.sp_defense;
		d.speed = +d.speed;
		d.height_m = +d.height_m;
		d.weight_kg = +d.weight_kg;
	});

	let xAxisVar = "capture_rate"
	let yAxisVar = "base_total"

	let xAxis
	let yAxis

	// create defs, linear gradient, and stop elements with appropriate settings
	var defs = scatterSvg.append("defs")
	for (type1 in typeColors) {
		for (type2 in typeColors) {
			var linGrad = defs.append("linearGradient")
				.attr("id", type1 + type2)
				.attr("x1", 0)
				.attr("x2", 1)
				.attr("y1", 0)
				.attr("y2", 1)

			linGrad.append("stop")
				.attr("offset", "0%")
				.attr("stop-color", typeColors[type1])
			
			linGrad.append("stop")
				.attr("offset", "100%")
				.attr("stop-color", typeColors[type2])
		}
	}

	// set scatterplot Tooltip display to none once it is fully transparent for better user experience (fewer issues with hovering over where tooltip text was which causes cursor issues)
	let hide = function() {scatterplotTooltip.style("display", "none")}
	let hideHandler


// -----------------------Function declarations--------------------------------//


	// handles y Variable dropdown menu change
	yDropdown.on("change", function() {
		// update yAxisVar's value
		let el = document.querySelector( ':focus' )
		if( el ) el.blur()
		yAxisVar = this.value
		updateScatter(xAxisVar, yAxisVar)
	})

	// handles x Variable dropdown menu change
	xDropdown.on("change", function() {
		// update xAxisVar's value
		let el = document.querySelector( ':focus' )
		if( el ) el.blur()
		xAxisVar = this.value
		updateScatter(xAxisVar, yAxisVar)
	})

	function updateScatter(xAxisVar, yAxisVar) {
		// no filtering needed yet for x and y axes changes

		// remove all information that could be changed
		exitDots()
		scatterSvg.selectAll('text')
			.data([])
			.exit()
			.remove()
		
		scatterSvg.select('.regressionLine')
			.data([])
			.exit()
			.remove()

		if (xAxis) {
			xAxis.data([]).exit().remove()
		}
		if (yAxis) {
			yAxis.data([]).exit().remove()
		}

		// reset domain
		x.domain([0, d3.max(data, function(d) { return d[xAxisVar]; }) + 5]);
		y.domain([d3.min(data, function(d) { return d[yAxisVar]; }) - 10, d3.max(data, function(d) { return d[yAxisVar]; }) + 20]);

		//Keeping these comments for now
		// updatePoints(groupData);
		// enterPoints(groupData);
		// exitPoints(groupData);
		// var group = e.target.value;
		// var groupData = getFilteredData(data, group);

		// format x and y axes for display in tooltips and axes
		let [xAxisVarFormatted, yAxisVarFormatted] = varNameFormat(xAxisVar, yAxisVar)

		// create all new dots with correct location
		enterDots(data, xAxisVarFormatted, yAxisVarFormatted)

		// Add x Axis
		xAxis = scatterSvg.append("g")
			.attr("transform", "translate(0," + height + ")")
			.call(d3.axisBottom(x));

		// Add y Axis
		yAxis = scatterSvg.append("g")
			.call(d3.axisLeft(y));

		scatterSvg.append('text')
			.attr("transform", "rotate(-90)")
			.attr('x', -height / 2)
			.attr('y', -margin.left / 1.5)
			.style('font-size', 20)
			.style('text-anchor', 'middle')
			.text(yAxisVarFormatted)

		scatterSvg.append('text')
			.attr('x', width / 2)
			.attr('y', height + margin.bottom / 1.5)
			.style('font-size', 20)
			.style('text-anchor', 'middle')
			.text(xAxisVarFormatted)


	//---------------------Regression line-------------------//

		linearRegression = ss.linearRegression(data.map(d => [d[xAxisVar], d[yAxisVar]]))

		linearRegressionLine = ss.linearRegressionLine(linearRegression)

		const firstX = d3.min(data, function(d) { return d[xAxisVar]; });
		const lastX = d3.max(data, function(d) { return d[xAxisVar]; });
		const xCoordinates = [firstX, lastX];

		// these x and y keys coordinate with the line variable below
		let regressionPoints = xCoordinates.map(d => ({
			x: d,
			y: linearRegressionLine(d)
		}));
		
		regressionLine = d3.line()
			.x(d => x(d.x))
			.y(d => y(d.y))

		scatterSvg.append('path')
			.classed('regressionLine', true)
			.datum(regressionPoints)
			.attr('d', regressionLine)
			.attr('stroke', 'rgb(253, 251, 142)')
			.attr('stroke-width', 2);



		let scatterTitle = scatterSvg.append('text')
			.attr("class", "scatterTitle")
			.attr('x', width / 2)
			.attr('y', -10)
			.style('font-size', 30)
			.style('text-anchor', 'middle')
			.text('Pokemon Stats Compared')

		let SVGRect = d3.select(".scatterTitle").node().getBoundingClientRect()

		scatterSvg.append('rect')
			.attr("x", SVGRect.x - 80 + "px")
			.attr("y", SVGRect.y - 110 + "px")
			.attr("width", "100vw")
			.attr("height", 100)
			.attr("fill", "#ececec")
			.style('text-anchor', 'middle')
			.text(" ")

		scatterSvg.append('text')
			.attr("class", "scatterTitle")
			.attr('x', width / 2)
			.attr('y', -10)
			.style('font-size', 30)
			.style('text-anchor', 'middle')
			.text('Pokemon Stats Compared')
	}

	// formatting x and y axis variables for displaying with Capitalized first letters and no underscores
	function varNameFormat(xAxisVar, yAxisVar) {
		let tempArrX = xAxisVar.split("_")
		let xAxisVarFormatted = tempArrX[0].charAt(0).toUpperCase() + tempArrX[0].substring(1) + " " + tempArrX[1].charAt(0).toUpperCase() + tempArrX[1].substring(1)
		let tempArrY = yAxisVar.split("_")
		let yAxisVarFormatted
		if (tempArrY.length > 1) {
			yAxisVarFormatted = tempArrY[0].charAt(0).toUpperCase() + tempArrY[0].substring(1) + " " + tempArrY[1].charAt(0).toUpperCase() + tempArrY[1].substring(1)
			return [xAxisVarFormatted, yAxisVarFormatted]
		} else {
			yAxisVarFormatted = tempArrY[0].charAt(0).toUpperCase() + tempArrY[0].substring(1)
			return [xAxisVarFormatted, yAxisVarFormatted]
		}
	}
	// let [xAxisVarFormatted, yAxisVarFormatted] = varNameFormat(xAxisVar, yAxisVar)

	// Add all dots for the scatterplot
	function enterDots(data, xAxisVarFormatted, yAxisVarFormatted) {
		scatterSvg.selectAll("dot")
			.data(data)
		.enter().append("circle")
			.on("mouseover", function(d, i) { // show it and update html
				if (hideHandler) {
					clearTimeout(hideHandler)
				}

				let html = "<span class='tooltiptext'>" + "<b>" + d.name + "</b>" + "<br/>" + xAxisVarFormatted + ": " + d[xAxisVar] + "<br/>" + yAxisVarFormatted + ": " + d[yAxisVar]

				scatterplotTooltip.style("display", "block").html(html)
					.transition()
					.duration(500)
					.style("opacity", .9);
			})
			.on("mousemove", function(d, i) {
				let tempHeight = d3.select(".scatterplotTooltip").node().getBoundingClientRect().height
				let tempWidth = d3.select(".scatterplotTooltip").node().getBoundingClientRect().width
				console.log(tempHeight)
				
				scatterplotTooltip
					.style("left", (d3.event.offsetX - (tempWidth / 2) - 0.5) + "px")
					.style("top", (d3.event.offsetY - tempHeight - 12) + "px");
			})
			.on("mouseout", function(d, i) {
				scatterplotTooltip.transition()
					.duration(500)
					.style("opacity", 0)

				hideHandler = setTimeout(hide, 550)
			})
			.attr("r", 5)
			.attr("cx", function(d) { return x(d[xAxisVar]); })
			.attr("cy", function(d) { return y(d[yAxisVar]); })
			.attr("fill", function(d) {
				if (d.type2 === "") {
					return typeColors[d.type1]
				}
				return "url(#" + d.type1 + d.type2 + ")"
		})
	}


	function exitDots() {
		scatterSvg.selectAll("circle")
			.data([])
			.exit()
			.remove();
	}



// -------------------Run initializations/Function calls------------------------//

	updateScatter(xAxisVar, yAxisVar)

});
</script>