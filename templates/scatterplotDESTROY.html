<script>

    // set dimensions and margins of scatterplot
    var margin = {top: 40, right: 50, bottom: 60, left: 65},
        width = window.innerWidth - margin.left - margin.right - 30,
        height = 600 - margin.top - margin.bottom;
    
    // set the ranges of x and y axes
    var x = d3.scaleLinear().range([0, width]);
    var y = d3.scaleLinear().range([height, 0]);
    
    // svg create and setup + group element create/append that sets area to start in the corner with margins applied
    var svg = d3.select(".scatterDiv").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("color", "red")
        .attr("style", "background-color: lightgray")
        .call(responsivefy)
    .append("g")
        .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")");
    
    svg.append('text')
        .attr('x', width / 2)
        .attr('y', -10)
        .style('font-size', 30)
        .style('text-anchor', 'middle')
        .text('Pokemon Stats Compared')
    
    svg.append('text')
        .attr("transform", "rotate(-90)")
        .attr('x', -height / 2)
        .attr('y', -margin.left / 1.5)
        .style('font-size', 20)
        .style('text-anchor', 'middle')
        .text('Total base stats')
    
    svg.append('text')
        .attr('x', width / 2)
        .attr('y', height + margin.bottom / 1.5)
        .style('font-size', 20)
        .style('text-anchor', 'middle')
        .text('Capture rate')
    
    
    // Get the data and process data within a large function
    d3.csv("{{url_for('static', filename='data/pokemon.csv')}}").then(function(data) {
    
        // format data
        data.forEach(function(d) {
            d.capture_rate = +d.capture_rate;
            d.base_total = +d.base_total;
            // d.y = +d.y;
        });
    
        // Setup domain of data
        x.domain([0, d3.max(data, function(d) { return d.capture_rate; }) + 5]);
        y.domain([d3.min(data, function(d) { return d.base_total; }) - 10, d3.max(data, function(d) { return d.base_total; }) + 20]);
        
        // var line = d3.svg.line()
        // 	.x(function(d) {
        // 		return x(d.x);
        // 	})
        // 	.y(function(d) {
        // 		return y(d.y);
        // });
    
        // var line = svg.append('line')
        // 	.x(function(d) { return x(d['capture_rate']); })
        // 	.y(function(d) { return y(d['base_total']); });
    
        // create defs, linear gradient, and stop elements with appropriate settings
        var defs = svg.append("defs")
        for (type1 in typeColors) {
            for (type2 in typeColors) {
                var linGrad = defs.append("linearGradient")
                    .attr("id", type1 + type2)
                    .attr("x1", 0)
                    .attr("x2", 1)
                    .attr("y1", 0)
                    .attr("y2", 1)
    
                linGrad.append("stop")
                    .attr("offset", "0%")
                    .attr("stop-color", typeColors[type1])
                
                linGrad.append("stop")
                    .attr("offset", "100%")
                    .attr("stop-color", typeColors[type2])
            }
        }
                
        // Add all dots for the scatterplot
        svg.selectAll("dot")
            .data(data)
        .enter().append("circle")
            .attr("r", 5)
            .attr("cx", function(d) { return x(d.capture_rate); })
            .attr("cy", function(d) { return y(d.base_total); })
            .attr("fill", function(d) {
                return "url(#" + d.type1 + d.type2 + ")"
            })
    
        // Add x Axis
        svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));
    
        // Add y Axis
        svg.append("g")
            .call(d3.axisLeft(y));
    
        // var xScale = d3.scale.linear()
        // 	.range([margin.left, width], .1);
            
        // var yScale = d3.scale.linear()
        // 	.range([height, 0]);
    
        // svg.append("path")
        //     .datum(data)
        //     .attr("class", "line")
        //     .attr("d", line);
    
        var xScale = d3.scaleLinear()
            .range([margin.left, width], .1);
            
        var yScale = d3.scaleLinear()
            .range([height, 0]);
    
            var xLabels = data.map(function (d) { return d['capture_rate']; })
    
            xScale.domain(xLabels);
            yScale.domain([0, Math.round(d3.max(data, function(d) { return parseFloat(d['rate']); }))]);
    
            // get the x and y values for least squares
            var xSeries = d3.range(1, xLabels.length + 1);
            var ySeries = data.map(function(d) { return d['base_total']; });
            
            var leastSquaresCoeff = leastSquares(xSeries, ySeries);
            
            // apply the reults of the least squares regression
            var x1 = xLabels[0];
            var y1 = leastSquaresCoeff[0] + leastSquaresCoeff[1];
            var x2 = xLabels[xLabels.length - 1];
            var y2 = leastSquaresCoeff[0] * xSeries.length + leastSquaresCoeff[1];
            var trendData = [[x1,y1,x2,y2]];
            
            var trendline = svg.selectAll(".trendline")
                .data(trendData);
                
            
            trendline.enter()
                .append("line")
                .attr("class", "trendline")
                .attr("x1", function(d) { return xScale(d[0]); })
                .attr("y1", function(d) { return yScale(d[1]); })
                .attr("x2", function(d) { return xScale(d[2]); })
                .attr("y2", function(d) { return yScale(d[3]); })
                .attr("stroke", "blue")
                .attr("stroke-width", 1);
    
        // returns slope, intercept and r-square of the line
        function leastSquares(xSeries, ySeries) {
            var reduceSumFunc = function(prev, cur) { return prev + cur; };
            
            var xBar = xSeries.reduce(reduceSumFunc) * 1.0 / xSeries.length;
            var yBar = ySeries.reduce(reduceSumFunc) * 1.0 / ySeries.length;
    
            var ssXX = xSeries.map(function(d) { return Math.pow(d - xBar, 2); })
                .reduce(reduceSumFunc);
            
            var ssYY = ySeries.map(function(d) { return Math.pow(d - yBar, 2); })
                .reduce(reduceSumFunc);
                
            var ssXY = xSeries.map(function(d, i) { return (d - xBar) * (ySeries[i] - yBar); })
                .reduce(reduceSumFunc);
                
            var slope = ssXY / ssXX;
            var intercept = yBar - (xBar * slope);
            var rSquare = Math.pow(ssXY, 2) / (ssXX * ssYY);
            
            return [slope, intercept, rSquare];
        }
    
    });
    </script>